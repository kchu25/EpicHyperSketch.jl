

"""
    - vecRefArray::Vector{AbstractArray{IntType, 3}}
    Reference arrays on the selected features for each data point

    - combs::AbstractArray{IntType, 2}
    Combinations, store each combination horizontally. For example, 
    this can be generated by 
    ```julia
    using Combinatorics
    combinations(1:5, 3) |> collect |> hcat
    ````
"""
mutable struct Record
    # Reference arrays on the selected features for each data point
    vecRefArray::Vector{AbstractArray{IntType, 3}}
    # combinations, store each combination horizontally
    combs::AbstractArray{IntType, 2}
    # count-min sketch
    cms::CountMinSketch
    # selected combinations
    selectedCombs::Vector{AbstractArray{Bool, 2}}
    # case: :OrdinaryFeatures or :Convolution
    case::Symbol
    # size of the motif (number of features/filters per motif)
    motif_size::IntType
    # filter length (for convolution case)
    filter_len::Union{IntType, Nothing}
    # cuda
    use_cuda::Bool


    function Record(activation_dict::Dict{T, Vector{S}}, 
        motif_size::Integer;
        batch_size=BATCH_SIZE,
        use_cuda::Bool=true,
        filter_len::Union{Integer, Nothing}=nothing
        ) where {T <: Integer, S}

        # preprocess the activation_dict
        filter_empty!(activation_dict)
        sort_activation_dict!(activation_dict)
        # determine case and max_active_length
        case = dict_case(activation_dict)
        @info "Determined case: $case"
        max_active_len = get_max_active_len(activation_dict)
        @info "Max active length: $max_active_len"
        @info "Generating combinations and constructing reference arrays..."
        # generate combinations
        combs = generate_combinations(motif_size, max_active_len; use_cuda=use_cuda)
        vecRefArray = constructVecRefArrays(activation_dict, max_active_len; 
            batch_size=batch_size, case=case, use_cuda=use_cuda)
        @info "Generating sketch..."
        cms = CountMinSketch(motif_size; case=case, use_cuda=use_cuda)

        selectedCombs = [CUDA.fill(false, 
            (size(combs, 2), size(vecRefArray[i], 3))) 
                for i in eachindex(vecRefArray)]

        new(vecRefArray, combs, cms, selectedCombs, case, IntType(motif_size), IntType(filter_len), use_cuda)
    end
end

"""
    actual_motif_size(r::Record)

For `:OrdinaryFeatures`: Returns `motif_size` (one coefficient per feature position).
For `:Convolution`: Returns `2 * motif_size - 1` (coefficients for both features and distances).
"""
function actual_motif_size(r::Record)
    r.case == :OrdinaryFeatures && return r.motif_size
    r.case == :Convolution && return 2 * r.motif_size - 1
    error("Unsupported case: $(r.case)")
end


get_cuda_count_tuple2d(r::Record, i::Integer) = (size(r.combs, 2), size(r.vecRefArray[i], 3))
get_cuda_count_tuple3d(r::Record, i::Int) = 
    (size(r.combs, 2), size(r.cms.sketch, 1), size(r.vecRefArray[i], 3))

num_batches(r::Record) = length(r.vecRefArray)

##### below are helper functions for record construction #####

"""
    batch_count_and_last_size(dict, batch_size)
Return the number of batches needed and the size of the last batch.
"""
function batch_count_and_last_size(dict::Dict{T, Vector{S}}, batch_size::Integer=BATCH_SIZE) where {T <: Integer, S}
    total = length(dict)
    num_batches = cld(total, batch_size)  # ceiling division
    last_batch_size = total == 0 ? 0 : total % batch_size == 0 ? batch_size : total % batch_size
    return num_batches, last_batch_size
end


"""
    constructVecRefArrays(activation_dict, max_active_len; batch_size, case, use_cuda)

Constructs batched reference arrays for each data point, storing features or convolution info in a 3D array. 
    Optionally moves arrays to GPU if `use_cuda` is true.
"""
function constructVecRefArrays(
        activation_dict::Dict{T, Vector{S}},
        max_active_len::Integer; 
        batch_size=BATCH_SIZE,
        case::Symbol=:OrdinaryFeatures,
        use_cuda::Bool=true
        ) where {T <: Integer, S}

    num_batches, last_batch_size = batch_count_and_last_size(activation_dict, batch_size)

    sizes = fill(batch_size, num_batches - 1)
    last_batch_size > 0 && push!(sizes, last_batch_size)
    vecRefArray = [zeros(IntType, (max_active_len, refArraysSecondDim[case], sz)) for sz in sizes]

    for (index, data_pt_index) in enumerate(keys(activation_dict))
        batch_index = div(index - 1, batch_size) + 1
        within_batch_index = (index - 1) % batch_size + 1

        features = activation_dict[data_pt_index]        
        if case == :OrdinaryFeatures
            vecRefArray[batch_index][1:length(features), 1, within_batch_index] .= convert.(IntType, features)
        elseif case == :Convolution
            for (i, feat) in enumerate(features)
                vecRefArray[batch_index][i, FILTER_INDEX_COLUMN, within_batch_index] = convert(IntType, feat.filter)
                vecRefArray[batch_index][i, POSITION_COLUMN, within_batch_index] = convert(IntType, feat.position)
            end
        else
            error("Unsupported case: $case")
        end
    end

    if use_cuda
        vecRefArray = CuArray.(vecRefArray)
    end
    return vecRefArray
end

"""
    generate_combinations(motif_size, max_active_len; use_cuda=true)
"""
function generate_combinations(motif_size::Integer, max_active_len::Integer; use_cuda=true)
    # Generate all combinations of motif_size from 1:max_active_len and store as IntType matrix
    comb_list = collect(combinations(1:max_active_len, motif_size))
    comb_matrix = reduce(hcat, comb_list)
    combs = IntType.(comb_matrix)
    if use_cuda
        combs = CuArray(combs)
    end
    return combs
end

"""
    get_max_active_len(dict)
Return the maximum length among all vectors in the dictionary.
"""
function get_max_active_len(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
    maximum(length, values(dict))
end

const OrdinaryFeatureType = Int
const ConvolutionFeatureType = NamedTuple{(:filter, :position), Tuple{Int, Int}}

function dict_case(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
    if S == OrdinaryFeatureType
        return :OrdinaryFeatures
    elseif S == ConvolutionFeatureType
        return :Convolution
    else
        error("Unsupported element type in dictionary values")
    end
end

"""
    sort_activation_dict!(activation_dict; case=:OrdinaryFeatures)
Sorts each vector in the activation dictionary in-place. For :Convolution, sorts by position field.
"""
function sort_activation_dict!(activation_dict::Dict{T, Vector{S}}; case=:OrdinaryFeatures) where {T<:Integer, S}
    sort_by = case == :OrdinaryFeatures ? identity : x -> x.position
    for v in values(activation_dict)
        sort!(v, by=sort_by)
    end
end

"""
    filter_empty!(dict)
Filter out keys with empty values from the dictionary.
"""
function filter_empty!(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
     for k in keys(dict)
        isempty(dict[k]) && delete!(dict, k)
    end
end
