"""
    - vecRefArray::Vector{AbstractArray{IntType, 3}}
    Reference arrays on the selected features for each data point

    - combs::AbstractArray{IntType, 2}
    Combinations, store each combination horizontally. For example, 
    this can be generated by 
    ```julia
    using Combinatorics
    combinations(1:5, 3) |> collect |> hcat
    ````
"""
mutable struct Record
    # Reference arrays on the selected features for each data point
    vecRefArray::Vector{AbstractArray{IntType, 3}}
    # Reference arrays for contributions
    vecRefArrayContrib::Vector{AbstractArray{FloatType, 2}}
    # combinations, store each combination horizontally
    combs::AbstractArray{IntType, 2}
    # count-min sketch
    cms::CountMinSketch
    # selected combinations
    selectedCombs::Vector{AbstractArray{Bool, 2}}
    # case: :OrdinaryFeatures or :Convolution
    case::Symbol
    # size of the motif (number of features/filters per motif)
    motif_size::IntType
    # filter length (for convolution case)
    filter_len::Union{IntType, Nothing}
    # cuda
    use_cuda::Bool


    function Record(activation_dict::Dict{T, Vector{S}}, 
        motif_size::Integer;
        batch_size::Union{Integer, Symbol}=BATCH_SIZE,
        use_cuda::Bool=true,
        filter_len::Union{Integer, Nothing}=nothing,
        seed::Union{Int, Nothing}=nothing,
        auto_batch_verbose::Bool=false
        ) where {T <: Integer, S}

        # preprocess the activation_dict

        filter_empty!(activation_dict)
        # determine case and max_active_length
        case = dict_case(activation_dict)
        sort_activation_dict!(activation_dict, case=case)
        @info "Determined case: $case"
        max_active_len = get_max_active_len(activation_dict)
        @info "Max active length: $max_active_len"
        
        # Auto-calculate batch size if requested
        if batch_size == :auto
            result = auto_configure_batch_size(activation_dict, motif_size, case; 
                                              use_cuda=use_cuda, verbose=auto_batch_verbose)
            batch_size = result.batch_size
            @info "Auto-configured batch_size: $batch_size ($(result.num_batches) batches, ~$(round(result.estimated_peak_memory_gb, digits=2)) GB estimated)"
        elseif batch_size isa Integer
            @info "Using specified batch_size: $batch_size"
        else
            error("batch_size must be an Integer or :auto")
        end
        
        @info "Generating combinations and constructing reference arrays..."
        # generate combinations
        combs = generate_combinations(motif_size, max_active_len; use_cuda=use_cuda)
        vecRefArray, vecRefArrayContrib = constructVecRefArrays(activation_dict, max_active_len; 
            batch_size=batch_size, case=case, use_cuda=use_cuda)
        @info "Generating sketch..."
        cms = CountMinSketch(motif_size; case=case, use_cuda=use_cuda, seed=seed)

        selectedCombs = use_cuda ?
            [CUDA.fill(false, (size(combs, 2), size(vecRefArray[i], 3))) for i in eachindex(vecRefArray)] :
            [fill(false, (size(combs, 2), size(vecRefArray[i], 3))) for i in eachindex(vecRefArray)]

        new(
            vecRefArray,
            vecRefArrayContrib,
            combs,
            cms,
            selectedCombs,
            case,
            IntType(motif_size),
            !isnothing(filter_len) ? IntType(filter_len) : nothing,
            use_cuda
        )
    end
end

"""
    actual_motif_size(r::Record)

For `:OrdinaryFeatures`: Returns `motif_size` (one coefficient per feature position).
For `:Convolution`: Returns `2 * motif_size - 1` (coefficients for both features and distances).
"""
# function actual_motif_size(r::Record)
#     r.case == :OrdinaryFeatures && return r.motif_size
#     r.case == :Convolution && return 2 * r.motif_size - 1
#     error("Unsupported case: $(r.case)")
# end


get_cuda_count_tuple2d(r::Record, i::Integer) = (size(r.combs, 2), size(r.vecRefArray[i], 3))
get_cuda_count_tuple3d(r::Record, i::Int) = 
    (size(r.combs, 2), size(r.cms.sketch, 1), size(r.vecRefArray[i], 3))

num_batches(r::Record) = length(r.vecRefArray)

##### below are helper functions for record construction #####

"""
    batch_count_and_last_size(dict, batch_size)
Return the number of batches needed and the size of the last batch.
"""
function batch_count_and_last_size(dict::Dict{T, Vector{S}}, batch_size::Integer=BATCH_SIZE) where {T <: Integer, S}
    total = length(dict)
    num_batches = cld(total, batch_size)  # ceiling division
    last_batch_size = total == 0 ? 0 : total % batch_size == 0 ? batch_size : total % batch_size
    return num_batches, last_batch_size
end


"""
    constructVecRefArrays(activation_dict, max_active_len; batch_size, case, use_cuda)

Constructs batched reference arrays for each data point, storing features or convolution info in a 3D array. 
    Optionally moves arrays to GPU if `use_cuda` is true.
"""
function constructVecRefArrays(
        activation_dict::Dict{T, Vector{S}},
        max_active_len::Integer; 
        batch_size=BATCH_SIZE,
        case::Symbol=:OrdinaryFeatures,
        use_cuda::Bool=true
        ) where {T <: Integer, S}

    num_batches, last_batch_size = batch_count_and_last_size(activation_dict, batch_size)

    sizes = fill(batch_size, num_batches - 1)
    last_batch_size > 0 && push!(sizes, last_batch_size)
    vecRefArray = [zeros(IntType, (max_active_len, refArraysDim[case], sz)) for sz in sizes]
    vecRefArrayContrib = [zeros(FloatType, (max_active_len, sz)) for sz in sizes]
    # each vecRefArray[i] is a 3D array of size (max_active_len, 1 or 2, batch_size) 

    for (index, data_pt_index) in enumerate(keys(activation_dict))
        batch_index = div(index - 1, batch_size) + 1
        within_batch_index = (index - 1) % batch_size + 1

        features = activation_dict[data_pt_index]        
        if case == :OrdinaryFeatures
            for (i, feat) in enumerate(features)
                vecRefArray[batch_index][i, FILTER_INDEX_COLUMN, within_batch_index] = convert(IntType, feat.feature)
                vecRefArray[batch_index][i, DATA_PT_INDEX_COLUMN, within_batch_index] = convert(IntType, data_pt_index)
                vecRefArrayContrib[batch_index][i, within_batch_index] = convert(FloatType, feat.contribution)
            end
        elseif case == :Convolution
            for (i, feat) in enumerate(features)
                vecRefArray[batch_index][i, FILTER_INDEX_COLUMN, within_batch_index] = convert(IntType, feat.filter)
                vecRefArray[batch_index][i, POSITION_COLUMN, within_batch_index] = convert(IntType, feat.position)
                vecRefArray[batch_index][i, DATA_PT_INDEX_COLUMN, within_batch_index] = convert(IntType, data_pt_index)
                vecRefArrayContrib[batch_index][i, within_batch_index] = convert(FloatType, feat.contribution)
            end
        else
            error("Unsupported case: $case")
        end
    end

    if use_cuda
        vecRefArray = CuArray.(vecRefArray)
        vecRefArrayContrib = CuArray.(vecRefArrayContrib)
    end
    return vecRefArray, vecRefArrayContrib
end

"""
    generate_combinations(motif_size, max_active_len; use_cuda=true)
"""
function generate_combinations(motif_size::Integer, max_active_len::Integer; use_cuda=true)
    # Generate all combinations of motif_size from 1:max_active_len and store as IntType matrix
    comb_list = collect(combinations(1:max_active_len, motif_size))
    comb_matrix = reduce(hcat, comb_list)
    combs = IntType.(comb_matrix)
    if use_cuda
        combs = CuArray(combs)
    end
    return combs
end

"""
    get_max_active_len(dict)
Return the maximum length among all vectors in the dictionary.
"""
function get_max_active_len(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
    maximum(length, values(dict))
end

const OrdinaryFeatureType = NamedTuple{(:feature, :contribution), Tuple{Int, FloatType}}
const ConvolutionFeatureType = NamedTuple{(:filter, :contribution, :position), Tuple{Int, FloatType, Int}}

function dict_case(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
    println("Element type in dictionary values: $S")
    if S == OrdinaryFeature
        return :OrdinaryFeatureType
    elseif S == ConvolutionFeatureType
        return :Convolution
    else
        error("Unsupported element type in dictionary values")
    end
end

"""
    sort_activation_dict!(activation_dict; case=:OrdinaryFeatures)
Sorts each vector in the activation dictionary in-place. For :Convolution, sorts by position field.
"""
function sort_activation_dict!(activation_dict::Dict{T, Vector{S}}; case=:OrdinaryFeatures) where {T<:Integer, S}
    sort_by = case == :OrdinaryFeatures ? identity : x -> x.position
    for v in values(activation_dict)
        sort!(v, by=sort_by)
    end
end

"""
    filter_empty!(dict)
Filter out keys with empty values from the dictionary.
"""
function filter_empty!(dict::Dict{T, Vector{S}}) where {T <: Integer, S}
     for k in keys(dict)
        isempty(dict[k]) && delete!(dict, k)
    end
end
