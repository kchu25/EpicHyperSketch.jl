var documenterSearchIndex = {"docs":
[{"location":"#EpicHyperSketch","page":"Home","title":"EpicHyperSketch","text":"Documentation for EpicHyperSketch.\n\n","category":"section"},{"location":"#EpicHyperSketch.CountMinSketch","page":"Home","title":"EpicHyperSketch.CountMinSketch","text":"CountMinSketch(motif_size::Integer; delta, epsilon, use_cuda, seed)\n\nCreate a CountMinSketch object.\n\nmotif_size: Number of features (motifs).\ndelta: Error probability.\nepsilon: Error tolerance.\nuse_cuda: If true, use CUDA arrays.\nseed: Random seed for reproducibility (optional).\n\n\n\n\n\n","category":"type"},{"location":"#EpicHyperSketch.HyperSketchConfig","page":"Home","title":"EpicHyperSketch.HyperSketchConfig","text":"Configuration parameters for EpicHyperSketch operations.\n\n\n\n\n\n","category":"type"},{"location":"#EpicHyperSketch.HyperSketchError","page":"Home","title":"EpicHyperSketch.HyperSketchError","text":"Custom exceptions for EpicHyperSketch.\n\n\n\n\n\n","category":"type"},{"location":"#EpicHyperSketch.PartitionedRecord","page":"Home","title":"EpicHyperSketch.PartitionedRecord","text":"PartitionedRecord\n\nA structure for sequentially processing activation_dict partitions with a shared CountMinSketch. Stores partition data but creates Records on-demand to minimize memory usage.\n\nFields\n\npartitions::Vector{Dict}: Activation dict partitions (each subset by length)\nshared_cms::CountMinSketch: The shared count-min sketch\npartition_ranges::Vector{UnitRange{Int}}: Length ranges for each partition\nmotif_size::IntType: Size of motifs\ncase::Symbol: Processing case (:OrdinaryFeatures or :Convolution)\nfilter_len::Union{IntType, Nothing}: Filter length for convolution case\nuse_cuda::Bool: Whether to use CUDA\nbatch_size::Union{Int, Symbol}: Batch size (:auto or integer)\nauto_batch_verbose::Bool: Whether to print auto batch size details\n\n\n\n\n\n","category":"type"},{"location":"#EpicHyperSketch.Record","page":"Home","title":"EpicHyperSketch.Record","text":"- vecRefArray::Vector{AbstractArray{IntType, 3}}\nReference arrays on the selected features for each data point\n\n- combs::AbstractArray{IntType, 2}\nCombinations, store each combination horizontally. For example, \nthis can be generated by \n```julia\nusing Combinatorics\ncombinations(1:5, 3) |> collect |> hcat\n````\n\n\n\n\n\n","category":"type"},{"location":"#Base.getindex-Tuple{CountMinSketch, Int64, Int64}","page":"Home","title":"Base.getindex","text":"getindex(cms::CountMinSketch, i, j)\n\nAccess the sketch matrix at position (i, j).\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, CountMinSketch}","page":"Home","title":"Base.show","text":"show(io::IO, cms::CountMinSketch)\n\nCustom pretty printing for CountMinSketch objects.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{CountMinSketch}","page":"Home","title":"Base.size","text":"size(cms::CountMinSketch)\n\nReturn the size of the sketch matrix.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch._create_record_for_partition","page":"Home","title":"EpicHyperSketch._create_record_for_partition","text":"_create_record_for_partition(partition, pr::PartitionedRecord)\n\nInternal helper to create a Record for a single partition.\n\n\n\n\n\n","category":"function"},{"location":"#EpicHyperSketch._obtain_enriched_configurations_cpu_-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch._obtain_enriched_configurations_cpu_","text":"CPU version: Extract configurations where combinations exceed minimum count threshold. Returns a DataFrame with the same structure as the GPU version.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.auto_configure_batch_size-Tuple{Dict, Integer, Symbol}","page":"Home","title":"EpicHyperSketch.auto_configure_batch_size","text":"auto_configure_batch_size(activation_dict, motif_size, case; kwargs...)\n\nAutomatically determine optimal batch size for the given activation dictionary. This is a convenience function that analyzes the data and calls calculate_optimal_batch_size.\n\nArguments\n\nactivation_dict: The activation dictionary\nmotif_size: Size of motifs to search for  \ncase: :OrdinaryFeatures or :Convolution\nkwargs...: Additional arguments passed to calculate_optimal_batch_size\n\nReturns\n\nOptimal batch size and memory usage report as a NamedTuple\n\nExample\n\nresult = auto_configure_batch_size(activation_dict, 3, :Convolution; use_cuda=true)\nprintln(\"Recommended batch_size: \", result.batch_size)\nprintln(\"Memory per batch: \", result.memory_per_batch_mb, \" MB\")\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.batch_count_and_last_size-Union{Tuple{Dict{T, Vector{S}}}, Tuple{S}, Tuple{T}, Tuple{Dict{T, Vector{S}}, Integer}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.batch_count_and_last_size","text":"batch_count_and_last_size(dict, batch_size)\n\nReturn the number of batches needed and the size of the last batch.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.calculate_conv_hash-NTuple{8, Any}","page":"Home","title":"EpicHyperSketch.calculate_conv_hash","text":"Calculate hash index for convolution method, including position distances. Returns -1 if filters overlap (invalid combination).\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.calculate_conv_hash_cpu-NTuple{8, Any}","page":"Home","title":"EpicHyperSketch.calculate_conv_hash_cpu","text":"CPU version: Calculate hash index for convolution method, including position distances. Returns -1 if filters overlap (invalid combination).\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.calculate_optimal_batch_size-Tuple{Integer, Integer, Integer, Symbol}","page":"Home","title":"EpicHyperSketch.calculate_optimal_batch_size","text":"calculate_optimal_batch_size(\n    total_data_points, max_active_len, motif_size, case;\n    target_memory_gb=nothing, use_cuda=true, safety_factor=0.8,\n    delta=DEFAULT_CMS_DELTA, epsilon=DEFAULT_CMS_EPSILON\n)\n\nCalculate optimal batch size based on available memory and data structure requirements.\n\nArguments\n\ntotal_data_points: Total number of sequences in the dataset\nmax_active_len: Maximum number of active features/filters per sequence\nmotif_size: Size of motifs to search for\ncase: :OrdinaryFeatures or :Convolution\ntarget_memory_gb: Target memory budget in GB (default: auto-detect 80% of available)\nuse_cuda: Whether using GPU (affects available memory calculation)\nsafety_factor: Fraction of available memory to use (default: 0.8)\ndelta: Count-Min Sketch error probability\nepsilon: Count-Min Sketch error tolerance\n\nReturns\n\nOptimal batch size as an integer\n\nExample\n\nbatch_size = calculate_optimal_batch_size(\n    1000,  # 1000 sequences\n    50,    # max 50 active features\n    3,     # looking for triplets\n    :Convolution;\n    target_memory_gb=4.0  # use 4GB\n)\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.calculate_ordinary_hash-NTuple{7, Any}","page":"Home","title":"EpicHyperSketch.calculate_ordinary_hash","text":"Calculate hash index for ordinary (non-convolution) counting method.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.calculate_ordinary_hash_cpu-NTuple{7, Any}","page":"Home","title":"EpicHyperSketch.calculate_ordinary_hash_cpu","text":"CPU version: Calculate hash index for ordinary (non-convolution) counting method.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.check_cuda_requirements-Tuple{Bool}","page":"Home","title":"EpicHyperSketch.check_cuda_requirements","text":"Check CUDA availability and requirements.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.cms_cols-Tuple{Int64, Int64}","page":"Home","title":"EpicHyperSketch.cms_cols","text":"cms_cols(num_counters, rows)\n\nCalculate the number of columns in the sketch given num_counters and rows.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.cms_num_counters-Tuple{Int64, Float64}","page":"Home","title":"EpicHyperSketch.cms_num_counters","text":"cms_num_counters(rows, epsilon)\n\nCalculate the total number of counters in the sketch given rows and error tolerance epsilon.\n\nNote: The counters simply means the total number of cells in the sketch matrix.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.cms_rows-Tuple{Float64}","page":"Home","title":"EpicHyperSketch.cms_rows","text":"cms_rows(delta)\n\nCalculate the number of rows in the Count-Min Sketch given the error probability delta.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.constructVecRefArrays-Union{Tuple{S}, Tuple{T}, Tuple{Dict{T, Vector{S}}, Integer}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.constructVecRefArrays","text":"constructVecRefArrays(activation_dict, max_active_len; batch_size, case, use_cuda)\n\nConstructs batched reference arrays for each data point, storing features or convolution info in a 3D array.      Optionally moves arrays to GPU if use_cuda is true.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_conv_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.count_conv_cpu!","text":"CPU version: Execute counting on the sketch for convolution case.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.count_cpu!","text":"CPU version: Main counting function dispatcher.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_kernel_conv-NTuple{5, Any}","page":"Home","title":"EpicHyperSketch.count_kernel_conv","text":"CUDA kernel for convolution-based counting with position-aware hashing. Works with filter/feature combinations, skips when filters overlap.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_kernel_conv_get_candidates-NTuple{7, Any}","page":"Home","title":"EpicHyperSketch.count_kernel_conv_get_candidates","text":"CUDA kernel for convolution-based candidate selection with position-aware hashing. Computes minimum across all hash functions for proper Count-Min Sketch behavior.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_kernel_ordinary-NTuple{4, Any}","page":"Home","title":"EpicHyperSketch.count_kernel_ordinary","text":"CUDA kernel for ordinary counting of filter/feature combinations without position constraints.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_kernel_ordinary_get_candidate-NTuple{6, Any}","page":"Home","title":"EpicHyperSketch.count_kernel_ordinary_get_candidate","text":"CUDA kernel for ordinary candidate selection without position constraints. Computes minimum across all hash functions for proper Count-Min Sketch behavior.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.count_ordinary_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.count_ordinary_cpu!","text":"CPU version: Execute counting on the sketch for ordinary case.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.create_partitioned_record-Union{Tuple{S}, Tuple{T}, Tuple{Dict{T, Vector{S}}, Integer}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.create_partitioned_record","text":"create_partitioned_record(activation_dict, motif_size; kwargs...)\n\nCreate a PartitionedRecord that splits the activation_dict by value lengths and shares a single CountMinSketch. Records are created on-demand during processing to minimize memory usage.\n\nArguments\n\nactivation_dict: Dictionary mapping data point IDs to feature vectors\nmotif_size: Number of features per motif\npartition_width: Width of length ranges for partitioning (default: 10)\nbatch_size: Batch size per partition (can be :auto or Integer)\nuse_cuda: Whether to use CUDA (default: true)\nfilter_len: Filter length for convolution case\nseed: Random seed for sketch initialization\nauto_batch_verbose: Whether to print batch size info\n\nReturns\n\nA PartitionedRecord that processes partitions sequentially.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.default_config-Tuple{}","page":"Home","title":"EpicHyperSketch.default_config","text":"Get default configuration with optional overrides.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.estimate_fixed_memory-Tuple{Integer, Integer, Symbol}","page":"Home","title":"EpicHyperSketch.estimate_fixed_memory","text":"estimate_fixed_memory(max_active_len, motif_size, case; delta=DEFAULT_CMS_DELTA, epsilon=DEFAULT_CMS_EPSILON)\n\nEstimate fixed memory consumption (shared across all batches) for the given configuration. Returns memory in bytes.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.estimate_memory_per_batch-Tuple{Integer, Integer, Symbol}","page":"Home","title":"EpicHyperSketch.estimate_memory_per_batch","text":"estimate_memory_per_batch(max_active_len, motif_size, case; delta=DEFAULT_CMS_DELTA, epsilon=DEFAULT_CMS_EPSILON)\n\nEstimate memory consumption per data point in a batch for the given configuration. Returns memory in bytes per data point.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.filter_empty!-Union{Tuple{Dict{T, Vector{S}}}, Tuple{S}, Tuple{T}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.filter_empty!","text":"filter_empty!(dict)\n\nFilter out keys with empty values from the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.generate_combinations-Tuple{Integer, Integer}","page":"Home","title":"EpicHyperSketch.generate_combinations","text":"generate_combinations(motif_size, max_active_len; use_cuda=true)\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.get_max_active_len-Union{Tuple{Dict{T, Vector{S}}}, Tuple{S}, Tuple{T}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.get_max_active_len","text":"get_max_active_len(dict)\n\nReturn the maximum length among all vectors in the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.is_combination_valid-NTuple{4, Any}","page":"Home","title":"EpicHyperSketch.is_combination_valid","text":"Check if all filters/features in a combination are present (non-zero) in refArray.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.is_combination_valid_cpu-NTuple{4, Any}","page":"Home","title":"EpicHyperSketch.is_combination_valid_cpu","text":"CPU version: Check if all filters/features in a combination are present (non-zero) in refArray.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.make_selection_conv_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.make_selection_conv_cpu!","text":"CPU version: Identify combinations that meet minimum count threshold for convolution case.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.make_selection_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.make_selection_cpu!","text":"CPU version: Main selection function dispatcher.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.make_selection_ordinary_cpu!-Tuple{Record, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.make_selection_ordinary_cpu!","text":"CPU version: Identify combinations that meet minimum count threshold for ordinary case.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.memory_info-Tuple{}","page":"Home","title":"EpicHyperSketch.memory_info","text":"Memory usage monitoring for CUDA operations.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.num_hash_columns-Tuple{Integer, Symbol}","page":"Home","title":"EpicHyperSketch.num_hash_columns","text":"num_hash_columns(motif_size, case)\n\nReturn the number of hash columns for the given motif size and case.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_enriched_configurations_cpu-Tuple{Dict{T, Vector{S}} where {T<:Integer, S}}","page":"Home","title":"EpicHyperSketch.obtain_enriched_configurations_cpu","text":"CPU version: Main function to obtain enriched configurations.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_enriched_configurations_partitioned-Tuple{Dict{T, Vector{S}} where {T<:Integer, S}}","page":"Home","title":"EpicHyperSketch.obtain_enriched_configurations_partitioned","text":"obtain_enriched_configurations_partitioned(activation_dict; kwargs...)\n\nMain entry point for partitioned processing. Automatically partitions the activation_dict by value lengths and processes each partition with optimal batch sizes while sharing a single CountMinSketch.\n\nEach partition is processed completely (count → select → extract) before moving to the next partition, ensuring memory efficiency and correctness.\n\nArguments\n\nactivation_dict: Dictionary mapping data point IDs to feature vectors\nmotif_size: Number of features per motif (default: 3)\npartition_width: Width of length ranges for partitioning (default: 10)\nfilter_len: Filter length for convolution case\nmin_count: Minimum count threshold (default: 1, recommended for partitioned processing)\nseed: Random seed for reproducibility\nconfig: HyperSketchConfig object (optional)\nverbose: Whether to print detailed progress information (default: false)\nOther arguments passed to partition creation\n\nReturns\n\nA DataFrame with enriched configurations from all partitions.\n\nExample\n\nmotifs = obtain_enriched_configurations_partitioned(\n    activation_dict,\n    motif_size=3,\n    partition_width=10,\n    batch_size=:auto,\n    min_count=1  # Recommended: use 1, filter DataFrame afterwards\n)\nfiltered = filter(row -> row.count >= 5, motifs)\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_motifs_conv!-NTuple{10, Any}","page":"Home","title":"EpicHyperSketch.obtain_motifs_conv!","text":"Extract configurations for convolution case: filter IDs and inter-filter distances.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_motifs_conv_cpu!-NTuple{10, Any}","page":"Home","title":"EpicHyperSketch.obtain_motifs_conv_cpu!","text":"CPU version: Extract configurations for convolution case - filter IDs, distances, positions, dataindex, contributions. Returns matrices: motifs, distances, positions, dataindex, contribs.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_motifs_ordinary!-NTuple{7, Any}","page":"Home","title":"EpicHyperSketch.obtain_motifs_ordinary!","text":"Extract configurations for ordinary case: only filter/feature IDs.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.obtain_motifs_ordinary_cpu!-NTuple{7, Any}","page":"Home","title":"EpicHyperSketch.obtain_motifs_ordinary_cpu!","text":"CPU version: Extract configurations for ordinary case - feature IDs, dataindex, contributions. Returns matrices: motifs, dataindex, contribs.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.optimize_kernel_params-Tuple{Integer, Tuple}","page":"Home","title":"EpicHyperSketch.optimize_kernel_params","text":"Optimize CUDA kernel launch parameters based on device capabilities.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.partition_by_length-Union{Tuple{Dict{T, Vector{S}}}, Tuple{S}, Tuple{T}, Tuple{Dict{T, Vector{S}}, Integer}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.partition_by_length","text":"partition_by_length(activation_dict, partition_width=10)\n\nPartition an activation dictionary into sub-dictionaries based on the length of the feature vectors.\n\nArguments\n\nactivation_dict: Dictionary mapping data point IDs to feature vectors\npartition_width: Width of each length range (default: 10)\n\nReturns\n\npartitions::Vector{Dict}: Vector of sub-dictionaries, one per partition\nranges::Vector{UnitRange{Int}}: Length ranges for each partition\n\nExample\n\npartitions, ranges = partition_by_length(activation_dict, 10)\n# ranges might be: [1:10, 11:20, 21:30, ...]\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.print_memory_report-Tuple{Dict, Integer, Symbol, HyperSketchConfig}","page":"Home","title":"EpicHyperSketch.print_memory_report","text":"print_memory_report(activation_dict, motif_size, case, config::HyperSketchConfig)\n\nPrint a detailed memory usage report for the given configuration.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.print_partition_stats-Tuple{PartitionedRecord}","page":"Home","title":"EpicHyperSketch.print_partition_stats","text":"print_partition_stats(pr::PartitionedRecord)\n\nPrint statistics about the partitions in a PartitionedRecord.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.sort_activation_dict!-Union{Tuple{Dict{T, Vector{S}}}, Tuple{S}, Tuple{T}} where {T<:Integer, S}","page":"Home","title":"EpicHyperSketch.sort_activation_dict!","text":"sort_activation_dict!(activation_dict; case=:OrdinaryFeatures)\n\nSorts each vector in the activation dictionary in-place. For :Convolution, sorts by position field.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.validate_activation_dict-Tuple{Dict{T, Vector{S}} where {T<:Integer, S}}","page":"Home","title":"EpicHyperSketch.validate_activation_dict","text":"Validate activation dictionary structure.\n\n\n\n\n\n","category":"method"},{"location":"#EpicHyperSketch.@gpu_time-Tuple{Any}","page":"Home","title":"EpicHyperSketch.@gpu_time","text":"Macro for timing GPU operations with proper synchronization.\n\n\n\n\n\n","category":"macro"},{"location":"#EpicHyperSketch.@validate-Tuple{Any, Any}","page":"Home","title":"EpicHyperSketch.@validate","text":"Macro for parameter validation with clear error messages.\n\n\n\n\n\n","category":"macro"}]
}
